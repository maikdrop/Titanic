MVP stands for Model-View-Presenter. Graphic 1 shows the theoretical concept of MVP.  In comparison to the common MVC (Model-View-Controller) pattern, MVP offers an additional entity, the Presenter. View and ViewController form the View entity. There are two different versions of MVP: Supervising Controller and Passive View. In Titanic the Passive View was implemented. It means that all data synchronization between View and Model is organised by the Presenter. The view is "dumb" as possible. There is no direct data binding between View and Model or View and Presenter. The View sends Intents via public API to the Presenter, it calls the public API of the Model and communicates back to the view via delegate methods. The Presenter is like a portal for the View to see and get relevant view-formatted model data in order to update their UI. It can be seen as a front door with a glass hole in the middle. Itâ€™s to be mentioned that only the Game Scene uses the MVP pattern. All other Scenes use MVC.

A big benefit of MVP is that you can avoid a massive ViewController (chapter 2.2) and create a reusable view and view controller.
